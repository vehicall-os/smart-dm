//! Fallback Rules Implementation

use feature_engine::FeatureVector;
use serde::{Deserialize, Serialize};
use tracing::{debug, warn};

/// Alert severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Severity {
    /// Low severity - log only
    Low,
    /// Medium severity - dashboard alert
    Medium,
    /// High severity - audible beep
    High,
    /// Critical - immediate attention
    Critical,
}

/// Fault types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Fault {
    /// Engine overheating
    Overheating,
    /// O2 sensor degradation
    O2SensorDegradation,
    /// Engine misfire
    Misfire,
    /// High engine load
    HighLoad,
    /// Fuel system issue
    FuelSystemIssue,
}

impl Fault {
    /// Get string representation
    pub fn as_str(&self) -> &'static str {
        match self {
            Fault::Overheating => "engine_overheating",
            Fault::O2SensorDegradation => "o2_sensor_degradation",
            Fault::Misfire => "engine_misfire",
            Fault::HighLoad => "high_engine_load",
            Fault::FuelSystemIssue => "fuel_system_issue",
        }
    }
}

/// Alert generated by fallback rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Alert {
    /// Fault type
    pub fault: Fault,
    /// Severity level
    pub severity: Severity,
    /// Timestamp
    pub timestamp_ms: u64,
    /// Human-readable message
    pub message: String,
    /// Recommended action
    pub recommended_action: String,
}

impl Alert {
    /// Create a new alert
    pub fn new(fault: Fault, severity: Severity) -> Self {
        let timestamp_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map(|d| d.as_millis() as u64)
            .unwrap_or(0);

        let (message, action) = match fault {
            Fault::Overheating => (
                "Engine temperature is critically high".to_string(),
                "Stop immediately, check coolant level".to_string(),
            ),
            Fault::O2SensorDegradation => (
                "O2 sensor readings are abnormal".to_string(),
                "Schedule O2 sensor inspection".to_string(),
            ),
            Fault::Misfire => (
                "Engine misfire detected".to_string(),
                "Check spark plugs and ignition system".to_string(),
            ),
            Fault::HighLoad => (
                "Engine load is unusually high".to_string(),
                "Reduce acceleration, check for issues".to_string(),
            ),
            Fault::FuelSystemIssue => (
                "Fuel system anomaly detected".to_string(),
                "Check fuel quality and injectors".to_string(),
            ),
        };

        Self {
            fault,
            severity,
            timestamp_ms,
            message,
            recommended_action: action,
        }
    }
}

/// Threshold configuration for fallback rules
#[derive(Debug, Clone)]
pub struct FallbackThresholds {
    /// Coolant temp threshold for overheating warning (°C)
    pub coolant_warning: f64,
    /// Coolant temp threshold for critical overheating (°C)
    pub coolant_critical: f64,
    /// RPM std dev threshold for misfire detection
    pub rpm_std_dev_threshold: f64,
    /// Engine load threshold for high load warning (%)
    pub engine_load_threshold: f64,
}

impl Default for FallbackThresholds {
    fn default() -> Self {
        Self {
            coolant_warning: 100.0,
            coolant_critical: 110.0,
            rpm_std_dev_threshold: 500.0,
            engine_load_threshold: 90.0,
        }
    }
}

/// Fallback engine for rule-based fault detection
pub struct FallbackEngine {
    /// Thresholds for rule evaluation
    thresholds: FallbackThresholds,
    /// Whether engine is active
    active: bool,
}

impl FallbackEngine {
    /// Create a new fallback engine
    pub fn new(thresholds: FallbackThresholds) -> Self {
        Self {
            thresholds,
            active: true,
        }
    }

    /// Evaluate features and generate alerts
    pub fn evaluate(&self, features: &FeatureVector) -> Vec<Alert> {
        if !self.active {
            return Vec::new();
        }

        let mut alerts = Vec::new();

        // Check coolant temperature
        if features.coolant_temp_mean_30s > self.thresholds.coolant_critical {
            warn!("Critical overheating: {}°C", features.coolant_temp_mean_30s);
            alerts.push(Alert::new(Fault::Overheating, Severity::Critical));
        } else if features.coolant_temp_mean_30s > self.thresholds.coolant_warning {
            debug!("Overheating warning: {}°C", features.coolant_temp_mean_30s);
            alerts.push(Alert::new(Fault::Overheating, Severity::Medium));
        }

        // Check for misfire (high RPM variation)
        if features.rpm_std_dev > self.thresholds.rpm_std_dev_threshold {
            debug!("Possible misfire: RPM std_dev = {}", features.rpm_std_dev);
            alerts.push(Alert::new(Fault::Misfire, Severity::Medium));
        }

        // Check rapid temperature rise
        if features.coolant_temp_rate > 2.0 {
            debug!("Rapid temp rise: {}°C/sample", features.coolant_temp_rate);
            alerts.push(Alert::new(Fault::Overheating, Severity::High));
        }

        alerts
    }

    /// Activate the fallback engine
    pub fn activate(&mut self) {
        self.active = true;
    }

    /// Deactivate the fallback engine
    pub fn deactivate(&mut self) {
        self.active = false;
    }

    /// Check if engine is active
    pub fn is_active(&self) -> bool {
        self.active
    }
}

impl Default for FallbackEngine {
    fn default() -> Self {
        Self::new(FallbackThresholds::default())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normal_operation() {
        let engine = FallbackEngine::default();
        let features = FeatureVector {
            coolant_temp_mean_30s: 85.0,
            rpm_std_dev: 50.0,
            ..Default::default()
        };
        
        let alerts = engine.evaluate(&features);
        assert!(alerts.is_empty());
    }

    #[test]
    fn test_overheating_detection() {
        let engine = FallbackEngine::default();
        let features = FeatureVector {
            coolant_temp_mean_30s: 115.0, // Above critical
            ..Default::default()
        };
        
        let alerts = engine.evaluate(&features);
        assert!(!alerts.is_empty());
        assert_eq!(alerts[0].fault, Fault::Overheating);
        assert_eq!(alerts[0].severity, Severity::Critical);
    }

    #[test]
    fn test_misfire_detection() {
        let engine = FallbackEngine::default();
        let features = FeatureVector {
            rpm_std_dev: 600.0, // Above threshold
            ..Default::default()
        };
        
        let alerts = engine.evaluate(&features);
        assert!(!alerts.is_empty());
        assert_eq!(alerts[0].fault, Fault::Misfire);
    }
}
